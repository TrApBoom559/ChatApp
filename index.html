<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Ultra Secure E2E Chat — Mobile friendly</title>

<!-- Firebase (compat used как в оригинале) -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

<style>
  :root{
    --accent:#2563eb; --muted:#64748b; --bg:#f6f8fb; --card:#ffffff; --ok:#16a34a; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter, Roboto, Arial, sans-serif;background:var(--bg);color:#0f172a;-webkit-font-smoothing:antialiased}
  .app{max-width:980px;margin:0 auto;height:100vh;display:flex;flex-direction:column}
  header{background:linear-gradient(90deg,var(--accent),#1d4ed8);color:#fff;padding:12px 14px;display:flex;align-items:center;justify-content:space-between;gap:12px}
  header .brand{font-weight:700;font-size:17px}
  header .controls{display:flex;align-items:center;gap:8px}
  header .controls button{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.08);color:#fff;padding:8px 10px;border-radius:10px;cursor:pointer}
  main{flex:1;display:flex;padding:12px;gap:12px;align-items:stretch;min-height:0}

  /* single column for mobile */
  .panel{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 6px 20px rgba(16,24,40,.06);flex:1;display:flex;flex-direction:column;min-width:0}
  .entry{width:100%}
  .row{display:flex;gap:8px;margin-bottom:8px}
  input[type="text"], input[type="password"], input, textarea{flex:1;padding:12px;border-radius:10px;border:1px solid #e6eefc;font-size:15px;background:#fbfdff}
  .btn{padding:10px 12px;border-radius:10px;border:none;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
  .btn.ghost{background:#fff;border:1px solid #e6eefc;color:var(--accent)}
  .status-ok{color:var(--ok);font-size:13px}
  .status-err{color:var(--danger);font-size:13px}
  hr{border:none;border-top:1px solid #eef2f7;margin:12px 0}

  /* chat layout */
  .chat-top{display:flex;justify-content:space-between;align-items:flex-start;gap:12px}
  .badge{background:#eef4ff;color:#1e40af;padding:6px 8px;border-radius:8px;font-size:13px}
  .room-meta{display:flex;flex-direction:column;gap:6px}
  .room-id{font-weight:700;font-size:17px;word-break:break-all}
  .owner-line{font-size:13px;color:var(--muted)}
  .fp-compact{font-family:monospace;font-size:12px;background:#fbfdff;padding:8px;border-radius:8px;border:1px dashed #e6eefc;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .participants{background:#fff;border-radius:10px;padding:8px;border:1px solid #eef4ff;flex:0 0 auto;margin-top:8px}
  .participant{display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:8px}
  .messages-area{flex:1;overflow:auto;padding:12px;border-radius:10px;border:1px solid #eef4ff;background:linear-gradient(180deg,#fff,#fbfdff);min-height:220px}
  .msg-row{max-width:84%;display:block;margin-bottom:10px}
  .msg-row.mine{margin-left:auto;text-align:right}
  .msg-meta{font-size:12px;color:#344054;margin-bottom:6px}
  .msg{padding:12px;border-radius:12px;background:#f1f5f9;border:1px solid #e6eefc;display:inline-block;word-break:break-word}
  .mine .msg{background:#dcfce7}
  .composer{display:flex;gap:8px;padding-top:10px;align-items:center}
  .composer input{flex:1;padding:12px;border-radius:999px;border:1px solid #e6eefc;background:#fff}
  .small{font-size:13px;color:var(--muted);}

  /* mobile tweaks */
  @media (max-width:600px){
    main{flex-direction:column;padding:10px}
    header{padding:10px}
    .room-id{font-size:16px}
    .btn{padding:10px; font-size:15px}
    .messages-area{min-height:260px}
  }

  /* controls for code block */
  .code-block{background:#fbfdff;padding:10px;border-radius:8px;border:1px dashed #e6eefc;font-family:monospace;overflow:auto}
  .flex-row{display:flex;gap:8px;align-items:center}
  .muted-btn{background:#fff;border:1px solid #eef4ff;color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">Ultra Secure E2E Chat</div>
    <div class="controls">
      <div id="header-nick" class="small"></div>
      <button id="profile-btn">Профиль</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <!-- ENTRY -->
      <div id="entry" class="entry">
        <h2>Добро пожаловать</h2>

        <label>Ник (без пробелов)</label>
        <div class="row"><input id="nick-input" type="text" placeholder="Например: TrApBoom"></div>

        <label>Пароль</label>
        <div class="row"><input id="pwd-input" type="password" placeholder="Пароль (мин. 6)"></div>

        <div id="nick-status"></div>

        <div class="row">
          <button id="register-btn" class="btn">Зарегистрировать</button>
          <button id="login-btn" class="btn ghost">Войти</button>
        </div>

        <hr>

        <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px;">
          <div class="flex-row">
            <button id="create-btn" class="btn">Создать комнату</button>
            <div class="small" style="margin-left:6px;">Создаёт короткий ID и ключ (E2E)</div>
          </div>

          <div style="display:flex;gap:8px;align-items:center;">
            <input id="join-input" placeholder="ID комнаты (короткий код) или вставьте публичный ключ" style="padding:10px;border-radius:8px;border:1px solid #e6eefc;flex:1;background:#fff">
            <button id="join-btn" class="btn ghost">Подать заявку</button>
          </div>
        </div>

        <div class="small">Совет: копируйте короткий ID комнаты (он короче и удобнее), длинный публичный ключ можно скрыть в интерфейсе.</div>
      </div>

      <!-- PROFILE -->
      <div id="profile" class="profile" style="display:none">
        <h2>Профиль</h2>
        <p>Ваш ник: <b id="profile-nick">—</b></p>
        <div style="display:flex;gap:8px;margin-bottom:8px;">
          <button id="logout-btn" class="btn ghost">Выйти (локально)</button>
          <button id="delete-btn" class="btn" style="background:var(--danger);color:#fff">Удалить аккаунт</button>
        </div>

        <hr/>
        <h3>Смена пароля</h3>
        <div class="row"><input id="newpwd1" type="password" placeholder="Новый пароль"></div>
        <div class="row"><input id="newpwd2" type="password" placeholder="Повторите пароль"></div>
        <button id="changepwd-btn" class="btn ghost">Сменить пароль</button>
        <div id="pwd-status" class="small"></div>

        <hr/>
        <div style="display:flex;gap:8px;">
          <button id="back-btn" class="btn">Назад</button>
        </div>
      </div>

      <!-- CHAT -->
      <div id="chat-panel" style="display:none;flex-direction:column;height:100%;gap:10px;">
        <div class="chat-top" style="align-items:center;">
          <div class="room-meta">
            <div class="small">ID комнаты (короткий)</div>
            <div id="session-id" class="room-id">—</div>
            <div class="owner-line">Владелец: <span id="owner-nick">—</span></div>
          </div>

          <div style="display:flex;flex-direction:column;align-items:flex-end;gap:8px;">
            <div class="badge">Участников: <span id="participants-count">0</span></div>

            <div style="width:220px;">
              <div style="font-weight:700;margin-bottom:6px">Код комнаты</div>
              <div class="code-block">
                <div id="code-short" style="font-weight:600;font-size:15px;word-break:break-all">—</div>
                <div id="pub-key-wrapper" style="margin-top:8px;display:none;">
                  <div class="small" style="margin-bottom:4px">Публичный ключ (длинный, E2E)</div>
                  <div id="public-key" class="code-block" style="max-height:110px;overflow:auto;font-family:monospace;white-space:normal"></div>
                </div>
                <div style="display:flex;gap:8px;margin-top:8px;">
                  <button id="copy-id" class="muted-btn">Копировать ID</button>
                  <button id="toggle-key" class="muted-btn">Показать ключ</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div style="display:flex;gap:12px;flex-direction:column;margin-top:8px;">
          <div class="messages-area" id="messages-area"></div>

          <form id="msg-form" class="composer">
            <input id="msg-input" placeholder="Введите сообщение..." disabled>
            <button id="send-btn" class="btn" disabled>Отправить</button>
          </form>

          <div class="participants">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
              <div style="font-weight:700">Участники</div>
              <div class="small" id="participants-count-top">0</div>
            </div>
            <div id="participants-list" style="display:flex;flex-direction:column;gap:4px;max-height:160px;overflow:auto"></div>
          </div>
        </div>
      </div>

    </section>
  </main>
</div>

<script>
/* ====== CONFIG (твой Firebase, оставлен оригинал) ====== */
const firebaseConfig = {
  apiKey: "AIzaSyDHL6xRYLKGIJnjlMgIbX8XlNVfSOI2cIY",
  authDomain: "chat-5ac4f.firebaseapp.com",
  projectId: "chat-5ac4f",
  storageBucket: "chat-5ac4f.firebasestorage.app",
  messagingSenderId: "68050436057",
  appId: "1:68050436057:web:71ffddbe76b0765291a3c8",
  measurementId: "G-XFCT24V2MS"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
const auth = firebase.auth();

/* ====== DOM refs ====== */
const entry = document.getElementById('entry');
const profile = document.getElementById('profile');
const chatPanel = document.getElementById('chat-panel');

const nickInput = document.getElementById('nick-input');
const pwdInput = document.getElementById('pwd-input');
const nickStatus = document.getElementById('nick-status');

const registerBtn = document.getElementById('register-btn');
const loginBtn = document.getElementById('login-btn');

const createBtn = document.getElementById('create-btn');
const joinInput = document.getElementById('join-input');
const joinBtn = document.getElementById('join-btn');

const profileBtn = document.getElementById('profile-btn');
const profileNick = document.getElementById('profile-nick');
const headerNick = document.getElementById('header-nick');

const logoutBtn = document.getElementById('logout-btn');
const deleteBtn = document.getElementById('delete-btn');
const changepwdBtn = document.getElementById('changepwd-btn');
const newpwd1 = document.getElementById('newpwd1');
const newpwd2 = document.getElementById('newpwd2');
const pwdStatus = document.getElementById('pwd-status');
const backBtn = document.getElementById('back-btn');

const sessionIdEl = document.getElementById('session-id');
const ownerNickEl = document.getElementById('owner-nick');

const codeShort = document.getElementById('code-short');
const publicKeyEl = document.getElementById('public-key');
const pubKeyWrapper = document.getElementById('pub-key-wrapper');
const toggleKeyBtn = document.getElementById('toggle-key');
const copyIdBtn = document.getElementById('copy-id');

const participantsCountEl = document.getElementById('participants-count');
const participantsCountTop = document.getElementById('participants-count-top');
const participantsList = document.getElementById('participants-list');

const messagesArea = document.getElementById('messages-area');
const msgForm = document.getElementById('msg-form');
const msgInput = document.getElementById('msg-input');
const sendBtn = document.getElementById('send-btn');

let me = null;
let myNick = null;
let myNickId = null;
let ecdh = null;
let session = null;          // short session id (doc id)
let roomKey = null;         // AES key for messages
let partRef = null;
let ownerPub = null;
let displayed = new Set();
let showPubKey = false;

/* ====== Crypto helpers (original ones preserved) ====== */
function ab2b64(ab){ return btoa(String.fromCharCode(...new Uint8Array(ab))); }
function b642ab(b){ const bin = atob(b); const a = new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) a[i]=bin.charCodeAt(i); return a.buffer; }

async function genECDH(){ return crypto.subtle.generateKey({name:'ECDH',namedCurve:'P-256'}, true, ['deriveBits']); }
async function expPub(k){ return ab2b64(await crypto.subtle.exportKey('raw', k)); }
async function impPub(b64){ return crypto.subtle.importKey('raw', b642ab(b64), {name:'ECDH',namedCurve:'P-256'}, true, []); }
async function der(priv, pub){ const bits = await crypto.subtle.deriveBits({name:'ECDH', public: pub}, priv, 256); return crypto.subtle.importKey('raw', bits, {name:'AES-GCM'}, false, ['encrypt','decrypt']); }

async function genAES(){ return crypto.subtle.generateKey({name:'AES-GCM', length:256}, true, ['encrypt','decrypt']); }
async function expRaw(k){ return await crypto.subtle.exportKey('raw', k); }
async function impRaw(buf){ return crypto.subtle.importKey('raw', buf, {name:'AES-GCM'}, false, ['encrypt','decrypt']); }

async function enc(k, t){ const iv = crypto.getRandomValues(new Uint8Array(12)); const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, k, new TextEncoder().encode(t)); return {iv: ab2b64(iv), ct: ab2b64(ct)}; }
async function dec(k, ivB64, ctB64){ const iv = new Uint8Array(b642ab(ivB64)); const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, k, b642ab(ctB64)); return new TextDecoder().decode(pt); }

async function derivePasswordBits(password, saltUint8Array, iterations=150000){
  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey('raw', enc.encode(password), {name:'PBKDF2'}, false, ['deriveBits']);
  return crypto.subtle.deriveBits({name:'PBKDF2', salt: saltUint8Array, iterations, hash: 'SHA-256'}, key, 256);
}

/* UI helpers */
function showEntry(){ entry.style.display='block'; profile.style.display='none'; chatPanel.style.display='none'; headerNick.textContent=''; }
function showProfile(){ entry.style.display='none'; profile.style.display='block'; chatPanel.style.display='none'; profileNick.textContent = myNick || '—'; headerNick.textContent = myNick ? `👤 ${myNick}` : ''; }
function showChat(){ entry.style.display='none'; profile.style.display='none'; chatPanel.style.display='flex'; headerNick.textContent = myNick ? `👤 ${myNick}` : ''; msgInput.disabled = false; sendBtn.disabled = false; }
function setStatus(msg, ok=true){ nickStatus.innerHTML = ok ? `<span class="status-ok">${msg}</span>` : `<span class="status-err">${msg}</span>`; }

/* ====== Auth & init ====== */
auth.signInAnonymously().then(async r=>{
  me = r.user;
  ecdh = await genECDH();
  attachHandlers();

  // try restore nick by uid
  try {
    const q = await db.collection('nicknames').where('uid','==', me.uid).limit(1).get();
    if(!q.empty){
      const doc = q.docs[0];
      myNickId = doc.id;
      myNick = doc.data().display || myNickId;
      headerNick.textContent = `👤 ${myNick}`;
      setStatus('Вы восстановлены из сервера — вы вошли', true);
    } else {
      showEntry();
    }
  } catch(e){
    console.error('restore fail', e);
    showEntry();
  }
}).catch(e=>{ console.error('auth error', e); alert('Ошибка авторизации'); });

/* ====== Handlers setup ====== */
function attachHandlers(){
  // nick live check
  let tmr = null;
  nickInput.addEventListener('input', ()=>{
    clearTimeout(tmr);
    const n = nickInput.value.trim();
    if(!n || /\s/.test(n)){ nickStatus.textContent=''; return; }
    const id = n.toLowerCase();
    tmr = setTimeout(async ()=>{
      try{
        const snap = await db.collection('nicknames').doc(id).get();
        if(snap.exists) setStatus('Ник занят — нажмите Войти', false); else setStatus('Ник свободен', true);
      }catch(e){ nickStatus.textContent=''; }
    }, 250);
  });

  // Register
  registerBtn.addEventListener('click', async ()=>{
    if(!me) return alert('Подождите авторизацию');
    const n = nickInput.value.trim(); const pwd = pwdInput.value || '';
    if(!n || /\s/.test(n)) return setStatus('Неверный ник', false);
    if(pwd.length < 6) return setStatus('Пароль минимум 6 символов', false);
    const id = n.toLowerCase();
    const ref = db.collection('nicknames').doc(id);
    try{
      await db.runTransaction(async tx=>{
        const s = await tx.get(ref);
        if(s.exists) throw new Error('occupied');
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const bits = await derivePasswordBits(pwd, salt);
        tx.set(ref, {
          uid: me.uid,
          display: n,
          salt: ab2b64(salt.buffer),
          pwdHash: ab2b64(bits),
          lastSeen: firebase.firestore.FieldValue.serverTimestamp()
        });
      });
      myNick = n; myNickId = id;
      setStatus('Ник зарегистрирован ✔', true);
      headerNick.textContent = `👤 ${myNick}`;
    }catch(e){
      setStatus('Ник занят — нажмите Войти', false);
    }
  });

  // Login
  loginBtn.addEventListener('click', async ()=>{
    if(!me) return alert('Подождите авторизацию');
    const n = nickInput.value.trim(); const pwd = pwdInput.value || '';
    if(!n || /\s/.test(n)) return setStatus('Неверный ник', false);
    if(!pwd) return setStatus('Введите пароль', false);
    const id = n.toLowerCase();
    const ref = db.collection('nicknames').doc(id);
    try{
      const snap = await ref.get();
      if(!snap.exists) return setStatus('Ник не найден — зарегистрируйтесь', false);
      const d = snap.data();
      if(!d.salt || !d.pwdHash) return setStatus('Ник зарегистрирован неправильно', false);
      const saltBuf = b642ab(d.salt);
      const bits = await derivePasswordBits(pwd, new Uint8Array(saltBuf));
      const hashB64 = ab2b64(bits);
      if(hashB64 !== d.pwdHash) return setStatus('Неверный пароль', false);
      myNick = d.display || n; myNickId = id;
      setStatus('Вход выполнен ✔', true);
      headerNick.textContent = `👤 ${myNick}`;
      try { await ref.update({ lastSeen: firebase.firestore.FieldValue.serverTimestamp() }); } catch(e){}
    }catch(e){
      console.error(e);
      setStatus('Ошибка при входе', false);
    }
  });

  // Profile nav
  profileBtn.addEventListener('click', ()=>{
    if(!myNick) return alert('Сначала зарегистрируйтесь/войдите');
    showProfile();
  });
  backBtn.addEventListener('click', ()=>{ if(session) showChat(); else showEntry(); });

  // Logout / Delete / Change password
  logoutBtn.addEventListener('click', async ()=>{ myNick = null; myNickId = null; headerNick.textContent = ''; setStatus('Вы вышли локально.', true); showEntry(); });
  deleteBtn.addEventListener('click', async ()=>{
    if(!myNickId) return alert('Нет зарегистрированного ника');
    if(!confirm('Удалить аккаунт навсегда?')) return;
    try{
      const ref = db.collection('nicknames').doc(myNickId);
      const snap = await ref.get();
      if(snap.exists && snap.data().uid === me.uid){ await ref.delete(); } else { alert('Вы не владелец этого ника (удаление невозможно)'); }
    }catch(e){ console.error(e); alert('Ошибка удаления'); }
    myNick = null; myNickId = null; headerNick.textContent = '';
    showEntry();
  });
  changepwdBtn.addEventListener('click', async ()=>{
    const p1 = newpwd1.value || '', p2 = newpwd2.value || '';
    if(p1.length < 6) return pwdStatus.textContent = 'Минимум 6 символов';
    if(p1 !== p2) return pwdStatus.textContent = 'Пароли не совпадают';
    if(!myNickId) return pwdStatus.textContent = 'Нет ника';
    try{
      const ref = db.collection('nicknames').doc(myNickId);
      const snap = await ref.get();
      if(!snap.exists) return pwdStatus.textContent = 'Документ ника не найден';
      const data = snap.data();
      if(data.uid !== me.uid) return pwdStatus.textContent = 'Вы не владелец ника — изменить пароль нельзя';
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const bits = await derivePasswordBits(p1, salt);
      await ref.update({ salt: ab2b64(salt.buffer), pwdHash: ab2b64(bits) });
      pwdStatus.textContent = 'Пароль изменён ✔';
      newpwd1.value = ''; newpwd2.value = '';
    }catch(e){
      console.error(e);
      pwdStatus.textContent = 'Ошибка при смене пароля';
    }
  });

  /* ---------- Chat / session buttons (улучшено для мобильного) ---------- */

  // Create room — генерируем короткий ID и публикуем ownerPublicKey в документе
  createBtn.addEventListener('click', async ()=>{
    if(!myNick) return alert('Сначала зарегистрируйтесь/войдите');
    try{
      // короткий человекочитаемый id
      session = Math.random().toString(36).slice(2,10);
      sessionIdEl.textContent = session;
      ownerNickEl.textContent = myNick;
      ownerPub = await expPub(ecdh.publicKey);
      roomKey = await genAES();
      await db.collection('sessions').doc(session).set({
        ownerUid: me.uid,
        ownerNick: myNick,
        ownerPublicKey: ownerPub,
        ts: firebase.firestore.FieldValue.serverTimestamp()
      });
      // добавляем участника-владельца
      partRef = db.collection('sessions').doc(session).collection('participants').doc(me.uid);
      await partRef.set({ uid: me.uid, nickname: myNick, publicKey: ownerPub, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });

      // UI
      codeShort.textContent = session;
      publicKeyEl.textContent = ownerPub;
      pubKeyWrapper.style.display = 'none';
      toggleKeyBtn.textContent = 'Показать ключ';
      showChat();

      listenPartsOwner();
      listenMsgs();
      listenRequestsOwner();

      // copy handlers
      copyIdBtn.onclick = ()=>{ navigator.clipboard.writeText(session); copyIdBtn.textContent='Скопировано ✔'; setTimeout(()=>copyIdBtn.textContent='Копировать ID',1200); };
      toggleKeyBtn.onclick = ()=>{ showPubKey = !showPubKey; pubKeyWrapper.style.display = showPubKey ? 'block' : 'none'; toggleKeyBtn.textContent = showPubKey ? 'Скрыть ключ' : 'Показать ключ'; };
      alert('Комната создана. Короткий ID: ' + session + '\nЕго удобно копировать и отправлять участникам.');
    }catch(e){ console.error(e); alert('Ошибка создания комнаты'); }
  });

  // Join: поддерживаем ввод либо короткого ID, либо длинного публичного ключа (поиск)
  joinBtn.addEventListener('click', async ()=>{
    if(!myNick) return alert('Сначала зарегистрируйтесь/войдите');
    const raw = joinInput.value.trim(); if(!raw) return alert('Введите ID комнаты или вставьте публичный ключ владельца');
    try{
      let sid = raw;
      // если вероятно публичный ключ (длинный base64-like), поищем сессии по ownerPublicKey
      const maybePub = raw.length > 40;
      if(maybePub){
        const q = await db.collection('sessions').where('ownerPublicKey','==', raw).limit(1).get();
        if(!q.empty){
          sid = q.docs[0].id;
        } else {
          // try if user pasted public key with trailing spaces/newlines -> trim and search
          const trimmed = raw.replace(/\s+/g, '');
          const q2 = await db.collection('sessions').where('ownerPublicKey','==', trimmed).limit(1).get();
          if(!q2.empty) sid = q2.docs[0].id;
        }
      }

      const doc = await db.collection('sessions').doc(sid).get();
      if(!doc.exists) return alert('Комната не найдена (проверьте ID или вставьте публичный ключ владельца)');
      // Отправляем заявку (owner получит запрос и автоматически раздаст ключ, если одобрит)
      await db.collection('sessions').doc(sid).collection('requests').doc(me.uid).set({
        uid: me.uid,
        nickname: myNick,
        publicKey: await expPub(ecdh.publicKey),
        ts: firebase.firestore.FieldValue.serverTimestamp(),
        status: 'pending'
      });
      alert('Заявка отправлена владельцу комнаты. Ожидайте подтверждения.');
      session = sid;
      sessionIdEl.textContent = session;
      ownerNickEl.textContent = doc.data().ownerNick || '—';
      ownerPub = doc.data().ownerPublicKey || null;
      codeShort.textContent = session;
      publicKeyEl.textContent = ownerPub || '—';
      pubKeyWrapper.style.display = ownerPub ? 'none' : 'none';
      toggleKeyBtn.textContent = ownerPub ? 'Показать ключ' : '—';

      // слушаем participant doc на предмет encryptedRoomKey (owner раздаёт его)
      partRef = db.collection('sessions').doc(session).collection('participants').doc(me.uid);
      partRef.onSnapshot(async snap=>{
        if(snap.exists){
          const d = snap.data();
          if(d.encryptedRoomKey && !roomKey){
            try{
              // d.encryptedRoomKey stored as ivB64:ctB64
              const [ivB64, ctB64] = d.encryptedRoomKey.split(':');
              const op = await impPub(ownerPub);
              const derKey = await der(ecdh.privateKey, op);
              const raw = await crypto.subtle.decrypt({name:'AES-GCM', iv: new Uint8Array(b642ab(ivB64))}, derKey, b642ab(ctB64));
              roomKey = await impRaw(raw);
              listenMsgs();
              showChat();
              msgInput.disabled = false; sendBtn.disabled = false;
              alert('Вы подключены — ключ получен.');
            }catch(e){ console.error('decrypt roomKey fail', e); alert('Не удалось расшифровать ключ комнаты'); }
          }
        }
      });

    }catch(e){ console.error(e); alert('Ошибка отправки заявки или подключения'); }
  });

  // Listen for join requests (owner UI placeholder — можно развить)
  function listenRequestsOwner(){
    const reqCol = db.collection('sessions').doc(session).collection('requests');
    reqCol.onSnapshot(snapshot=>{
      // сейчас просто лог, расширение: показывать запросы во всплывающем списке
      snapshot.docChanges().forEach(ch=>{
        if(ch.type === 'added'){
          // новый запрос — автоматически добавляем в participants (в продакшне: спросить владельца)
          // Здесь: автоматически добавляем участника в participants (owner) и раздаём ключ.
          // Для простоты в этой демо — будем добавлять и раздавать.
          (async ()=>{
            const rq = ch.doc.data();
            // добавляем в participants если ещё нет
            const pRef = db.collection('sessions').doc(session).collection('participants').doc(rq.uid);
            const pSnap = await pRef.get();
            if(!pSnap.exists){
              await pRef.set({ uid: rq.uid, nickname: rq.nickname, publicKey: rq.publicKey, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
            }
            // пометим запрос как accepted (чтобы не повторять)
            await ch.doc.ref.update({ status: 'accepted' });
          })();
        }
      });
    });
  }

  // Owner: distribute roomKey to participants (при добавлении)
  function listenPartsOwner(){
    const col = db.collection('sessions').doc(session).collection('participants');
    col.onSnapshot(async snap=>{
      participantsCountEl.textContent = snap.size;
      participantsCountTop.textContent = snap.size;
      participantsList.innerHTML = '';
      for(const doc of snap.docs){
        const d = doc.data();
        const row = document.createElement('div');
        row.className = 'participant';
        row.innerHTML = `<div style="font-weight:600">${d.nickname||'—'}</div><div class="small">${d.uid===me.uid ? 'Я' : ''}</div>`;
        participantsList.appendChild(row);
      }
      for(const ch of snap.docChanges()){
        if(ch.type === 'added'){
          const d = ch.doc.data();
          // если я владелец и пользователь не имеет encryptedRoomKey — зашифруем и обновим
          if(d.publicKey && !d.encryptedRoomKey && me && d.uid !== undefined){
            try{
              const s = await db.collection('sessions').doc(session).get();
              if(s.exists && s.data().ownerUid === me.uid){
                const remotePub = await impPub(d.publicKey);
                const k = await der(ecdh.privateKey, remotePub);
                const raw = await expRaw(roomKey);
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, k, raw);
                await ch.doc.ref.update({ encryptedRoomKey: ab2b64(iv) + ':' + ab2b64(ct) });
              }
            }catch(e){ console.error('distribute key failed', e); }
          }
        }
      }
    });
  }

  // Messages listener (decrypt using roomKey)
  function listenMsgs(){
    messagesArea.innerHTML = '';
    db.collection('sessions').doc(session).collection('messages').orderBy('ts').onSnapshot(snap=>{
      snap.docChanges().forEach(async ch=>{
        if(ch.type === 'added'){
          if(displayed.has(ch.doc.id)) return;
          displayed.add(ch.doc.id);
          const d = ch.doc.data();
          if(!roomKey) return;
          try{
            const t = await dec(roomKey, d.iv, d.ct);
            addMsg(d.senderUid === me.uid ? myNick : (d.senderNick || 'Собеседник'), t, d.senderUid === me.uid);
          }catch(e){ console.error('decrypt msg fail', e); }
        }
      });
    });
  }

  // Send message
  msgForm.addEventListener('submit', async (ev)=>{
    ev.preventDefault();
    const text = msgInput.value.trim(); if(!text || !roomKey) return;
    try{
      const {iv, ct} = await enc(roomKey, text);
      await db.collection('sessions').doc(session).collection('messages').add({
        senderUid: me.uid, senderNick: myNick, iv, ct, ts: firebase.firestore.FieldValue.serverTimestamp()
      });
      msgInput.value = '';
    }catch(e){ console.error(e); }
  });

  function addMsg(nick, text, mine){
    const r = document.createElement('div'); r.className = 'msg-row' + (mine ? ' mine' : '');
    const m = document.createElement('div'); m.className = 'msg-meta'; m.textContent = nick;
    const b = document.createElement('div'); b.className = 'msg'; b.textContent = text;
    r.appendChild(m); r.appendChild(b); messagesArea.appendChild(r); messagesArea.scrollTop = messagesArea.scrollHeight;
  }

  // copy & toggle buttons (default noop until set)
  copyIdBtn.addEventListener('click', ()=>{ if(session) { navigator.clipboard.writeText(session); copyIdBtn.textContent='Скопировано ✔'; setTimeout(()=>copyIdBtn.textContent='Копировать ID',1200); } });
  toggleKeyBtn.addEventListener('click', ()=>{ showPubKey = !showPubKey; pubKeyWrapper.style.display = showPubKey ? 'block' : 'none'; toggleKeyBtn.textContent = showPubKey ? 'Скрыть ключ' : 'Показать ключ'; });

} // end attachHandlers

</script>
</body>
</html>
